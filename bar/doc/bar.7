.\"Text automatically generated by txt2man
.TH bar 7 "31 July 2011" "0.17" "Linux User's Manual"
.SH NAME
\fBbar \fP- backup archiver program
\fB
.SH SYNOPSIS
.nf
.fam C
\fBbar\fP [<options>] [--] <archive name> [<file>|<device>\.\.\.]
\fBbar\fP [<options>] [--] <key \fIfile\fP name>

.fam T
.fi
.fam T
.fi
.SH DESCRIPTION
BAR is a backup archiver program for files and disk images to create compressed,
encrypted and splitted archive files which can be stored on a local hard disk,
via network on a server or (with additional external tools) an optical medium
like a CD, DVD, or BD. It can create full and incremental/differential archives.
.PP
Archive files can be created, the content can be listed, tested, compared and
extracted. Individual archive files can be read independent. Listing the contents
of an archive is fast, even when the content is compressed and encrypted. The
content can be compressed with either \fBzip\fP(1), \fBbzip2\fP(1) or \fBlzma\fP(1). For encryption
several encryption algorithms from the libcrypt project like AES or TWOFISH can be
used. Public key encryption (RSA) is also supported.
.PP
CDs, DVDs, BDs with archive files can be created when the external tools
\fBgrowisofs\fP(1) and \fBmkisofs\fP(1) are installed. If the tool \fBdvdisaster\fP(1) is
available CDs and DVDs with additional error correction codes can be created.
.PP
BAR can be executed as a daemon and can created backups in the background via
the integrated scheduler. The BAR daemon can be controlled via a network
connection (either plain or SSL encrypted) with the graphical front end
\fBbarcontrol\fP(3).
.SH OPTIONS

.TP
.B
\fB-c\fP|\fB--create\fP
create new files archive
.RS
.TP
.B
\fB-m\fP|\fB--image\fP
create new images archive
.TP
.B
\fB-l\fP|\fB--list\fP
list contents of archive
.TP
.B
\fB-t\fP|\fB--test\fP
test contents of archive
.TP
.B
\fB-d\fP|\fB--compare\fP
compare contents of archive with files and images
.TP
.B
\fB-x\fP|\fB--extract\fP
restore archive
.TP
.B
\fB--generate-keys\fP
generate new public/private key pair
.TP
.B
\fB--generate-keys-bits\fP=<n>[K]
key bits (default: 1024)
.TP
.B
\fB--job\fP=<name>
execute job
.TP
.B
\fB--normal\fP
create normal archive (no incremental list \fIfile\fP)
.TP
.B
\fB-f\fP|\fB--full\fP
create full archive and incremental list \fIfile\fP
.TP
.B
\fB-i\fP|\fB--incremental\fP
create incremental archive
.TP
.B
\fB-I\fP|\fB--incremental-list\fP-\fIfile\fP=<\fIfile\fP name>
incremental list \fIfile\fP name (default: <archive name>.bid)
.TP
.B
\fB--differential\fP
create differential archive
.TP
.B
\fB--pattern-type\fP=<name>
select pattern type
.RS
.TP
.B
* glob
: glob patterns: * and ? (default)
.TP
.B
* regex
: regular expression pattern matching
.IP \(bu 3
extended: extended regular expression pattern matching
.RE
.TP
.B
-#|\fB--include\fP=<pattern>
include pattern
.TP
.B
-!|\fB--exclude\fP=<pattern>
exclude pattern
.TP
.B
\fB--config\fP=<\fIfile\fP name>
configuration \fIfile\fP
.TP
.B
\fB--tmp-directory\fP=<path>
temporary directory (default: /tmp)
.TP
.B
\fB--max-tmp-size\fP=<n>[G|M|K]
max. size of temporary files
.TP
.B
\fB-s\fP|\fB--archive-part-size\fP=<n>[G|M|K]
approximated archive part size
.TP
.B
\fB-p\fP|\fB--directory-strip\fP=<n>
number of directories to strip on extract
.TP
.B
\fB--destination\fP=<path>
destination to restore files/images
.TP
.B
\fB--owner\fP=<user:group>
user and group of restored files
.TP
.B
\fB-z\fP|\fB--compress-algorithm\fP=<name>
select compress algorithm to use
.RS
.IP \(bu 3
none : no compression (default)
.IP \(bu 3
zip0 : ZIP compression level 0
.IP \(bu 3
zip1 : ZIP compression level 1
.IP \(bu 3
zip2 : ZIP compression level 2
.IP \(bu 3
zip3 : ZIP compression level 3
.IP \(bu 3
zip4 : ZIP compression level 4
.IP \(bu 3
zip5 : ZIP compression level 5
.IP \(bu 3
zip6 : ZIP compression level 6
.IP \(bu 3
zip7 : ZIP compression level 7
.IP \(bu 3
zip8 : ZIP compression level 8
.IP \(bu 3
zip9 : ZIP compression level 9
.IP \(bu 3
bzip1: BZIP2 compression level 1
.IP \(bu 3
bzip2: BZIP2 compression level 2
.IP \(bu 3
bzip3: BZIP2 compression level 3
.IP \(bu 3
bzip4: BZIP2 compression level 4
.IP \(bu 3
bzip5: BZIP2 compression level 5
.IP \(bu 3
bzip6: BZIP2 compression level 6
.IP \(bu 3
bzip7: BZIP2 compression level 7
.IP \(bu 3
bzip8: BZIP2 compression level 8
.IP \(bu 3
bzip9: BZIP2 compression level 9
.IP \(bu 3
lzma1: LZMA compression level 1
.IP \(bu 3
lzma2: LZMA compression level 2
.IP \(bu 3
lzma3: LZMA compression level 3
.IP \(bu 3
lzma4: LZMA compression level 4
.IP \(bu 3
lzma5: LZMA compression level 5
.IP \(bu 3
lzma6: LZMA compression level 6
.IP \(bu 3
lzma7: LZMA compression level 7
.IP \(bu 3
lzma8: LZMA compression level 8
.IP \(bu 3
lzma9: LZMA compression level 9
.RE
.TP
.B
\fB--compress-min-size\fP=<n>[G|M|K]
minimal size of \fIfile\fP for compression (default: 32)
.TP
.B
\fB--compress-exclude\fP=<pattern>
exclude compression pattern
.TP
.B
\fB-y\fP|\fB--crypt-algorithm\fP=<name>
select crypt algorithm to use
.RS
.TP
.B
* none
: no crypting (default)
.TP
.B
* 3DES
: 3DES cipher
.TP
.B
* CAST5
: CAST5 cipher
.TP
.B
* BLOWFISH
: Blowfish cipher
.TP
.B
* AES128
: AES cipher 128bit
.TP
.B
* AES192
: AES cipher 192bit
.TP
.B
* AES256
: AES cipher 256bit
.IP \(bu 3
TWOFISH128: Twofish cipher 128bit
.IP \(bu 3
TWOFISH256: Twofish cipher 256bit
.RE
.TP
.B
\fB--crypt-type\fP=<name>
select crypt type
.RS
.IP \(bu 3
symmetric : symmetric
.IP \(bu 3
asymmetric: asymmetric
.RE
.TP
.B
\fB--crypt-password\fP=<password>
crypt password (use with care!)
.TP
.B
\fB--crypt-public-key\fP=<\fIfile\fP name>
public key for encryption
.TP
.B
\fB--crypt-private-key\fP=<\fIfile\fP name>
private key for decryption
.TP
.B
\fB--ftp-login-name\fP=<name>
ftp login name
.TP
.B
\fB--ftp-password\fP=<password>
ftp password (use with care!)
.TP
.B
\fB--ssh-port\fP=<n>
ssh port (default: 22)
.TP
.B
\fB--ssh-login-name\fP=<name>
ssh login name
.TP
.B
\fB--ssh-password\fP=<password>
ssh password (use with care!)
.TP
.B
\fB--ssh-public-key\fP=<\fIfile\fP name>
ssh public key \fIfile\fP name
.TP
.B
\fB--ssh-private-key\fP=<\fIfile\fP name>
ssh private key \fIfile\fP name
.TP
.B
\fB--daemon\fP
run in daemon mode
.TP
.B
\fB-D\fP|\fB--no-detach\fP
do not detach in daemon mode
.TP
.B
\fB--server-port\fP=<n>
server port (default: 38523)
.TP
.B
\fB--server-tls-port\fP=<n>
TLS (SSL) server port (default: 38524)
.TP
.B
\fB--server-ca\fP-\fIfile\fP=<\fIfile\fP name>
TLS (SSL) server certificate authority \fIfile\fP (CA \fIfile\fP) (default: /etc/ssl/certs/\fBbar\fP-ca.pem)
.TP
.B
\fB--server-cert\fP-\fIfile\fP=<\fIfile\fP name>
TLS (SSL) server certificate \fIfile\fP (default: /etc/ssl/certs/\fBbar\fP-server-cert.pem)
.TP
.B
\fB--server-key\fP-\fIfile\fP=<\fIfile\fP name>
TLS (SSL) server key \fIfile\fP (default: /etc/ssl/private/\fBbar\fP-server-key.pem)
.TP
.B
\fB--server-password\fP=<password>
server password (use with care!)
.TP
.B
\fB--server-jobs-directory\fP=<path name>
server job directory (default: /etc/\fBbar\fP/jobs)
.TP
.B
\fB--nice-level\fP=<n>
general nice level of processes/threads
.TP
.B
\fB--max-band-width\fP=<n>[M|K]
max. network band width to use [bits/s]
.TP
.B
\fB--remote\fP-\fBbar\fP-executable=<\fIfile\fP name>
remote BAR executable
.TP
.B
--\fIfile\fP-write-pre-command=<command>
write \fIfile\fP pre-process command
.TP
.B
--\fIfile\fP-write-post-command=<command>
write \fIfile\fP post-process command
.TP
.B
\fB--ftp-write-pre-command\fP=<command>
write FTP pre-process command
.TP
.B
\fB--ftp-write-post-command\fP=<command>
write FTP post-process command
.TP
.B
\fB--scp-write-pre-command\fP=<command>
write SCP pre-process command
.TP
.B
\fB--scp-write-post-command\fP=<command>
write SCP post-process command
.TP
.B
\fB--sftp-write-pre-command\fP=<command>
write SFTP pre-process command
.TP
.B
\fB--sftp-write-post-command\fP=<command>
write SFTP post-process command
.TP
.B
\fB--cd-device\fP=<device name>
default CD device (default: /dev/cdrw)
.TP
.B
\fB--cd-request-volume-command\fP=<command>
request new CD volume command
.TP
.B
\fB--cd-unload-volume-command\fP=<command>
unload CD volume command (default: eject \fB-r\fP %device)
.TP
.B
\fB--cd-load-volume-command\fP=<command>
load CD volume command (default: eject \fB-t\fP %device)
.TP
.B
\fB--cd-volume-size\fP=<n>[G|M|K]
CD volume size
.TP
.B
\fB--cd-image-pre-command\fP=<command>
make CD image pre-process command
.TP
.B
\fB--cd-image-post-command\fP=<command>
make CD image post-process command
.TP
.B
\fB--cd-image-command\fP=<command>
make CD image command (default: nice mkisofs \fB-V\fP Backup \fB-volset\fP %number \fB-r\fP \fB-o\fP %image %directory)
.TP
.B
\fB--cd-ecc-pre-command\fP=<command>
make CD error-correction codes pre-process command
.TP
.B
\fB--cd-ecc-post-command\fP=<command>
make CD error-correction codes post-process command
.TP
.B
\fB--cd-ecc-command\fP=<command>
make CD error-correction codes command (default: nice dvdisaster \fB-mRS02\fP \fB-n\fP cd \fB-c\fP \fB-i\fP %image \fB-v\fP)
.TP
.B
\fB--cd-write-pre-command\fP=<command>
write CD pre-process command
.TP
.B
\fB--cd-write-post-command\fP=<command>
write CD post-process command
.TP
.B
\fB--cd-write-command\fP=<command>
write CD command (default: nice sh \fB-c\fP 'mkisofs \fB-V\fP Backup \fB-volset\fP %number \fB-r\fP \fB-o\fP %image %directory && cdrecord \fB-dummy\fP dev=%device %image')
.TP
.B
\fB--cd-write-image-command\fP=<command>
write CD image command (default: nice cdrecord \fB-dummy\fP dev=%device %image)
.TP
.B
\fB--dvd-device\fP=<device name>
default DVD device (default: /dev/dvd)
.TP
.B
\fB--dvd-request-volume-command\fP=<command>
request new DVD volume command
.TP
.B
\fB--dvd-unload-volume-command\fP=<command>
unload DVD volume command (default: eject \fB-r\fP %device)
.TP
.B
\fB--dvd-load-volume-command\fP=<command>
load DVD volume command (default: eject \fB-t\fP %device)
.TP
.B
\fB--dvd-volume-size\fP=<n>[G|M|K]
DVD volume size
.TP
.B
\fB--dvd-image-pre-command\fP=<command>
make DVD image pre-process command
.TP
.B
\fB--dvd-image-post-command\fP=<command>
make DVD image post-process command
.TP
.B
\fB--dvd-image-command\fP=<command>
make DVD image command (default: nice mkisofs \fB-V\fP Backup \fB-volset\fP %number \fB-r\fP \fB-o\fP %image %directory)
.TP
.B
\fB--dvd-ecc-pre-command\fP=<command>
make DVD error-correction codes pre-process command
.TP
.B
\fB--dvd-ecc-post-command\fP=<command>
make DVD error-correction codes post-process command
.TP
.B
\fB--dvd-ecc-command\fP=<command>
make DVD error-correction codes command (default: nice dvdisaster \fB-mRS02\fP \fB-n\fP dvd \fB-c\fP \fB-i\fP %image \fB-v\fP)
.TP
.B
\fB--dvd-write-pre-command\fP=<command>
write DVD pre-process command
.TP
.B
\fB--dvd-write-post-command\fP=<command>
write DVD post-process command
.TP
.B
\fB--dvd-write-command\fP=<command>
write DVD command (default: nice growisofs \fB-Z\fP %device \fB-A\fP BAR \fB-V\fP Backup \fB-volset\fP %number \fB-r\fP %\fIfile\fP)
.TP
.B
\fB--dvd-write-image-command\fP=<command>
write DVD image command (default: nice growisofs \fB-Z\fP %device=%image \fB-use-the-force-luke\fP=dao:%sectors \fB-use-the-force-luke\fP=noload)
.TP
.B
\fB--bd-device\fP=<device name>
default BD device (default: /dev/bd)
.TP
.B
\fB--bd-request-volume-command\fP=<command>
request new BD volume command
.TP
.B
\fB--bd-unload-volume-command\fP=<command>
unload BD volume command (default: eject \fB-r\fP %device)
.TP
.B
\fB--bd-load-volume-command\fP=<command>
load BD volume command (default: eject \fB-t\fP %device)
.TP
.B
\fB--bd-volume-size\fP=<n>[G|M|K]
BD volume size
.TP
.B
\fB--bd-image-pre-command\fP=<command>
make BD image pre-process command
.TP
.B
\fB--bd-image-post-command\fP=<command>
make BD image post-process command
.TP
.B
\fB--bd-image-command\fP=<command>
make BD image command (default: nice mkisofs \fB-V\fP Backup \fB-volset\fP %number \fB-r\fP \fB-o\fP %image %directory)
.TP
.B
\fB--bd-ecc-pre-command\fP=<command>
make BD error-correction codes pre-process command
.TP
.B
\fB--bd-ecc-post-command\fP=<command>
make BD error-correction codes post-process command
.TP
.B
\fB--bd-ecc-command\fP=<command>
make BD error-correction codes command (default: nice dvdisaster \fB-mRS02\fP \fB-n\fP bd \fB-c\fP \fB-i\fP %image \fB-v\fP)
.TP
.B
\fB--bd-write-pre-command\fP=<command>
write BD pre-process command
.TP
.B
\fB--bd-write-post-command\fP=<command>
write BD post-process command
.TP
.B
\fB--bd-write-command\fP=<command>
write BD command (default: nice growisofs \fB-Z\fP %device \fB-A\fP BAR \fB-V\fP Backup \fB-volset\fP %number \fB-r\fP %\fIfile\fP)
.TP
.B
\fB--bd-write-image-command\fP=<command>
write BD image command (default: nice growisofs \fB-Z\fP %device=%image \fB-use-the-force-luke\fP=dao:%sectors \fB-use-the-force-luke\fP=noload)
.TP
.B
\fB--device\fP=<device name>
default device
\fB--device-request-volume-command\fP=<command> request new volume command
.TP
.B
\fB--device-load-volume-command\fP=<command>
load volume command
.TP
.B
\fB--device-unload-volume-command\fP=<command>
unload volume command
.TP
.B
\fB--device-volume-size\fP=<n>[G|M|K]
volume size
.TP
.B
\fB--device-image-pre-command\fP=<command>
make image pre-process command
.TP
.B
\fB--device-image-post-command\fP=<command>
make image post-process command
.TP
.B
\fB--device-image-command\fP=<command>
make image command
.TP
.B
\fB--device-ecc-pre-command\fP=<command>
make error-correction codes pre-process command
.TP
.B
\fB--device-ecc-post-command\fP=<command>
make error-correction codes post-process command
.TP
.B
\fB--device-ecc-command\fP=<command>
make error-correction codes command
.TP
.B
\fB--device-write-pre-command\fP=<command>
write device pre-process command
.TP
.B
\fB--device-write-post-command\fP=<command>
write device post-process command
.TP
.B
\fB--device-write-command\fP=<command>
write device command
.TP
.B
\fB--ecc\fP
add error-correction codes with 'dvdisaster' tool
.TP
.B
\fB--always-create-image\fP
always create image for CD/DVD/BD/device
.TP
.B
\fB--database\fP-\fIfile\fP=<\fIfile\fP name>
index database \fIfile\fP name
.TP
.B
\fB--no-auto-update-database-index\fP
disabled automatic update database index
.TP
.B
\fB--log\fP=<name>[,<name>\.\.\.]
log types
.RS
.TP
.B
* none
: no logging (default)
.TP
.B
* errors
: log errors
.TP
.B
* warnings
: log warnings
.TP
.B
* ok
: log stored/restored files
.TP
.B
* unknown
: log unknown files
.TP
.B
* skipped
: log skipped files
.TP
.B
* missing
: log missing files
.IP \(bu 3
incomplete: log incomplete files
.TP
.B
* excluded
: log excluded files
.TP
.B
* storage
: log storage
.TP
.B
* all
: log everything
.RE
.TP
.B
\fB--log\fP-\fIfile\fP=<\fIfile\fP name>
log \fIfile\fP name
.TP
.B
\fB--log-post-command\fP=<command>
log \fIfile\fP post-process command
.TP
.B
\fB--pid\fP-\fIfile\fP=<\fIfile\fP name>
process id \fIfile\fP name
.TP
.B
\fB-g\fP|\fB--group\fP
group files in list
.TP
.B
\fB--all\fP
show all files
.TP
.B
\fB-L\fP|\fB--long-format\fP
list in long format
.TP
.B
\fB-H\fP|\fB--human-format\fP
list in human readable format
.TP
.B
\fB--no-header-footer\fP
output no header/footer in list
.TP
.B
\fB--delete-old-archive-files\fP
delete old archive files after creating new files
.TP
.B
\fB--ignore-no-backup\fP-\fIfile\fP
ignore .nobackup/.NOBACKUP \fIfile\fP
.TP
.B
\fB--skip-unreadable\fP
skip unreadable files
.TP
.B
\fB-o\fP|\fB--overwrite-archive-files\fP
overwrite existing archive files
.TP
.B
\fB--overwrite-files\fP
overwrite existing files
.TP
.B
\fB--wait-first-volume\fP
wait for first volume
.TP
.B
\fB--raw-images\fP
store raw images (store all image blocks)
.TP
.B
\fB--dry-run\fP
do dry-run (skip storage/restore, incremental data, database index)
.TP
.B
\fB--no-storage\fP
do not store archives (skip storage, database index)
.TP
.B
\fB--no\fP-\fBbar\fP-on-medium
do not store a copy of BAR on medium
.TP
.B
\fB--stop-on-error\fP
immediately stop on error
.TP
.B
\fB--no-default-config\fP
do not read personal config \fIfile\fP ~/.bar/bar.cfg
.TP
.B
\fB--quiet\fP
suppress any output
.TP
.B
\fB-v\fP|\fB--verbose\fP=<n>
verbosity level (0..3, default: 1)
.TP
.B
\fB--version\fP
output version
.TP
.B
\fB-h\fP|\fB--help\fP
output this help
.TP
.B
\fB--xhelp\fP
output help to extended options
.TP
.B
\fB--help-internal\fP
output help to internal options
.SH EXAMPLES
Create an archive:
.PP
.nf
.fam C
  bar -c home.bar /home

.fam T
.fi
List contents of an archive:
.PP
.nf
.fam C
  bar -l home*.bar

.fam T
.fi
or simply
.PP
.nf
.fam C
  bar home*.bar

.fam T
.fi
Check archive:
.PP
.nf
.fam C
  bar -t home*.bar

.fam T
.fi
Compare contents of an archive with files:
.PP
.nf
.fam C
  bar -d home*.bar

.fam T
.fi
Find most recent \fIfile\fP in all archives:
.PP
.nf
.fam C
  bar -g -# '*/foo' *.bar

.fam T
.fi
Restore contents of an archive:
.PP
.nf
.fam C
  bar -x home*.bar

.fam T
.fi
.SH FILES
/etc/\fBbar\fP/bar.cfg
.PP
.nf
.fam C
  system wide bar configuration

.fam T
.fi
/etc/\fBbar\fP/bar.jks
.PP
.nf
.fam C
  private key for SSL connection with bar daemon

.fam T
.fi
/etc/\fBbar\fP/jobs
.PP
.nf
.fam C
  jobs directory

.fam T
.fi
$HOME/.bar/bar.cfg
.PP
.nf
.fam C
  user specific configuration

.fam T
.fi
/etc/ssl/certs/\fBbar\fP-ca.pem, /etc/ssl/certs/\fBbar\fP-server-cert.pemq
.PP
.nf
.fam C
  BAR TLS/SSL certificates and public keys

.fam T
.fi
/etc/ssl/private/\fBbar\fP-server-key.pem
.PP
.nf
.fam C
  BAR TLS/SSL server private key


.fam T
.fi
.SH BUGS
Please report bugs to torsten.rupp@gmx.net. If possible compile BAR with
debugging enabled (configure option \fB--enable-debug\fP) and include a C stack
trace in the bug report.
